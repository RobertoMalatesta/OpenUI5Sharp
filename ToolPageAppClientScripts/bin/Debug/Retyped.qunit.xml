<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Retyped.qunit</name>
    </assembly>
    <members>
        <member name="M:Retyped.qunit.Assert.async">
            <summary>
            Instruct QUnit to wait for an asynchronous operation.
            The callback returned from `assert.async()` will throw an Error if it is
            invoked more than once (or more often than the accepted call count, if
            provided).
            This replaces functionality previously provided by `QUnit.stop()` and
            `QUnit.start()`.
            </summary>
        </member>
        <member name="M:Retyped.qunit.Assert.async(System.Double)">
            <summary>
            Instruct QUnit to wait for an asynchronous operation.
            The callback returned from `assert.async()` will throw an Error if it is
            invoked more than once (or more often than the accepted call count, if
            provided).
            This replaces functionality previously provided by `QUnit.stop()` and
            `QUnit.start()`.
            </summary>
            <param name = "acceptCallCount">Number of expected callbacks before the test is done.</param>
        </member>
        <member name="M:Retyped.qunit.Assert.deepEqual(System.Object,System.Object)">
            <summary>
            A deep recursive comparison, working on primitive types, arrays, objects,
            regular expressions, dates and functions.
            The `deepEqual()` assertion can be used just like `equal()` when comparing
            the value of objects, such that `{ key: value }` is equal to
            `{ key: value }`. For non-scalar values, identity will be disregarded by
            deepEqual.
            `notDeepEqual()` can be used to explicitly test deep, strict inequality.
            </summary>
            <param name = "actual">Object or Expression being tested</param>
            <param name = "expected">Known comparision value</param>
        </member>
        <member name="M:Retyped.qunit.Assert.deepEqual(System.Object,System.Object,System.String)">
            <summary>
            A deep recursive comparison, working on primitive types, arrays, objects,
            regular expressions, dates and functions.
            The `deepEqual()` assertion can be used just like `equal()` when comparing
            the value of objects, such that `{ key: value }` is equal to
            `{ key: value }`. For non-scalar values, identity will be disregarded by
            deepEqual.
            `notDeepEqual()` can be used to explicitly test deep, strict inequality.
            </summary>
            <param name = "actual">Object or Expression being tested</param>
            <param name = "expected">Known comparision value</param>
            <param name = "message">A short description of the assertion</param>
        </member>
        <member name="M:Retyped.qunit.Assert.equal(System.Object,System.Object)">
            <summary>
            A non-strict comparison, roughly equivalent to JUnit's assertEquals.
            The `equal` assertion uses the simple comparison operator (`==`) to
            compare the actual and expected arguments. When they are equal, the
            assertion passes; otherwise, it fails. When it fails, both actual and
            expected values are displayed in the test result, in addition to a given
            message.
            `notEqual()` can be used to explicitly test inequality.
            `strictEqual()` can be used to test strict equality.
            </summary>
            <param name = "actual">Expression being tested</param>
            <param name = "expected">Known comparison value</param>
        </member>
        <member name="M:Retyped.qunit.Assert.equal(System.Object,System.Object,System.String)">
            <summary>
            A non-strict comparison, roughly equivalent to JUnit's assertEquals.
            The `equal` assertion uses the simple comparison operator (`==`) to
            compare the actual and expected arguments. When they are equal, the
            assertion passes; otherwise, it fails. When it fails, both actual and
            expected values are displayed in the test result, in addition to a given
            message.
            `notEqual()` can be used to explicitly test inequality.
            `strictEqual()` can be used to test strict equality.
            </summary>
            <param name = "actual">Expression being tested</param>
            <param name = "expected">Known comparison value</param>
            <param name = "message">A short description of the assertion</param>
        </member>
        <member name="M:Retyped.qunit.Assert.expect(System.Double)">
            <summary>
            Specify how many assertions are expected to run within a test.
            To ensure that an explicit number of assertions are run within any test,
            use `assert.expect( number )` to register an expected count. If the
            number of assertions run does not match the expected count, the test will
            fail.
            </summary>
            <param name = "amount">Number of assertions in this test.</param>
        </member>
        <member name="M:Retyped.qunit.Assert.notDeepEqual(System.Object,System.Object)">
            <summary>
            An inverted deep recursive comparison, working on primitive types,
            arrays, objects, regular expressions, dates and functions.
            </summary>
            <param name = "actual">Object or Expression being tested</param>
            <param name = "expected">Known comparison value</param>
        </member>
        <member name="M:Retyped.qunit.Assert.notDeepEqual(System.Object,System.Object,System.String)">
            <summary>
            An inverted deep recursive comparison, working on primitive types,
            arrays, objects, regular expressions, dates and functions.
            </summary>
            <param name = "actual">Object or Expression being tested</param>
            <param name = "expected">Known comparison value</param>
            <param name = "message">A short description of the assertion</param>
        </member>
        <member name="M:Retyped.qunit.Assert.notEqual(System.Object,System.Object)">
            <summary>
            A non-strict comparison, checking for inequality.
            The `notEqual` assertion uses the simple inverted comparison operator
            (`!=`) to compare the actual and expected arguments. When they aren't
            equal, the assertion passes; otherwise, it fails. When it fails, both
            actual and expected values are displayed in the test result, in addition
            to a given message.
            `equal()` can be used to test equality.
            `notStrictEqual()` can be used to test strict inequality.
            </summary>
            <param name = "actual">Object or Expression being tested</param>
            <param name = "expected">Known comparison value</param>
        </member>
        <member name="M:Retyped.qunit.Assert.notEqual(System.Object,System.Object,System.String)">
            <summary>
            A non-strict comparison, checking for inequality.
            The `notEqual` assertion uses the simple inverted comparison operator
            (`!=`) to compare the actual and expected arguments. When they aren't
            equal, the assertion passes; otherwise, it fails. When it fails, both
            actual and expected values are displayed in the test result, in addition
            to a given message.
            `equal()` can be used to test equality.
            `notStrictEqual()` can be used to test strict inequality.
            </summary>
            <param name = "actual">Object or Expression being tested</param>
            <param name = "expected">Known comparison value</param>
            <param name = "message">A short description of the assertion</param>
        </member>
        <member name="M:Retyped.qunit.Assert.notOk(System.Object)">
            <summary>
            A boolean check, inverse of `ok()` and CommonJS's `assert.ok()`, and
            equivalent to JUnit's `assertFalse()`. Passes if the first argument is
            falsy.
            `notOk()` requires just one argument. If the argument evaluates to false,
            the assertion passes; otherwise, it fails. If a second message argument
            is provided, it will be displayed in place of the result.
            </summary>
            <param name = "state">Expression being tested</param>
        </member>
        <member name="M:Retyped.qunit.Assert.notOk(System.Object,System.String)">
            <summary>
            A boolean check, inverse of `ok()` and CommonJS's `assert.ok()`, and
            equivalent to JUnit's `assertFalse()`. Passes if the first argument is
            falsy.
            `notOk()` requires just one argument. If the argument evaluates to false,
            the assertion passes; otherwise, it fails. If a second message argument
            is provided, it will be displayed in place of the result.
            </summary>
            <param name = "state">Expression being tested</param>
            <param name = "message">A short description of the assertion</param>
        </member>
        <member name="M:Retyped.qunit.Assert.notPropEqual(System.Object,System.Object)">
            <summary>
            A strict comparison of an object's own properties, checking for inequality.
            The `notPropEqual` assertion uses the strict inverted comparison operator
            (`!==`) to compare the actual and expected arguments as Objects regarding
            only their properties but not their constructors.
            When they aren't equal, the assertion passes; otherwise, it fails. When
            it fails, both actual and expected values are displayed in the test
            result, in addition to a given message.
            `equal()` can be used to test equality.
            `propEqual()` can be used to test strict equality of an Object properties.
            </summary>
            <param name = "actual">Object or Expression being tested</param>
            <param name = "expected">Known comparison value</param>
        </member>
        <member name="M:Retyped.qunit.Assert.notPropEqual(System.Object,System.Object,System.String)">
            <summary>
            A strict comparison of an object's own properties, checking for inequality.
            The `notPropEqual` assertion uses the strict inverted comparison operator
            (`!==`) to compare the actual and expected arguments as Objects regarding
            only their properties but not their constructors.
            When they aren't equal, the assertion passes; otherwise, it fails. When
            it fails, both actual and expected values are displayed in the test
            result, in addition to a given message.
            `equal()` can be used to test equality.
            `propEqual()` can be used to test strict equality of an Object properties.
            </summary>
            <param name = "actual">Object or Expression being tested</param>
            <param name = "expected">Known comparison value</param>
            <param name = "message">A short description of the assertion</param>
        </member>
        <member name="M:Retyped.qunit.Assert.notStrictEqual(System.Object,System.Object)">
            <summary>
            A strict comparison, checking for inequality.
            The `notStrictEqual` assertion uses the strict inverted comparison
            operator (`!==`) to compare the actual and expected arguments. When they
            aren't equal, the assertion passes; otherwise, it fails. When it fails,
            both actual and expected values are displayed in the test result, in
            addition to a given message.
            `equal()` can be used to test equality.
            `strictEqual()` can be used to test strict equality.
            </summary>
            <param name = "actual">Object or Expression being tested</param>
            <param name = "expected">Known comparison value</param>
        </member>
        <member name="M:Retyped.qunit.Assert.notStrictEqual(System.Object,System.Object,System.String)">
            <summary>
            A strict comparison, checking for inequality.
            The `notStrictEqual` assertion uses the strict inverted comparison
            operator (`!==`) to compare the actual and expected arguments. When they
            aren't equal, the assertion passes; otherwise, it fails. When it fails,
            both actual and expected values are displayed in the test result, in
            addition to a given message.
            `equal()` can be used to test equality.
            `strictEqual()` can be used to test strict equality.
            </summary>
            <param name = "actual">Object or Expression being tested</param>
            <param name = "expected">Known comparison value</param>
            <param name = "message">A short description of the assertion</param>
        </member>
        <member name="M:Retyped.qunit.Assert.ok(System.Object)">
            <summary>
            A boolean check, equivalent to CommonJS's assert.ok() and JUnit's
            assertTrue(). Passes if the first argument is truthy.
            The most basic assertion in QUnit, ok() requires just one argument. If
            the argument evaluates to true, the assertion passes; otherwise, it
            fails. If a second message argument is provided, it will be displayed in
            place of the result.
            </summary>
            <param name = "state">Expression being tested</param>
        </member>
        <member name="M:Retyped.qunit.Assert.ok(System.Object,System.String)">
            <summary>
            A boolean check, equivalent to CommonJS's assert.ok() and JUnit's
            assertTrue(). Passes if the first argument is truthy.
            The most basic assertion in QUnit, ok() requires just one argument. If
            the argument evaluates to true, the assertion passes; otherwise, it
            fails. If a second message argument is provided, it will be displayed in
            place of the result.
            </summary>
            <param name = "state">Expression being tested</param>
            <param name = "message">A short description of the assertion</param>
        </member>
        <member name="M:Retyped.qunit.Assert.propEqual(System.Object,System.Object)">
            <summary>
            A strict type and value comparison of an object's own properties.
            The `propEqual()` assertion provides strictly (`===`) comparison of
            Object properties. Unlike `deepEqual()`, this assertion can be used to
            compare two objects made with different constructors and prototype.
            `strictEqual()` can be used to test strict equality.
            `notPropEqual()` can be used to explicitly test strict inequality of
            Object properties.
            </summary>
            <param name = "actual">Object or Expression being tested</param>
            <param name = "expected">Known comparison value</param>
        </member>
        <member name="M:Retyped.qunit.Assert.propEqual(System.Object,System.Object,System.String)">
            <summary>
            A strict type and value comparison of an object's own properties.
            The `propEqual()` assertion provides strictly (`===`) comparison of
            Object properties. Unlike `deepEqual()`, this assertion can be used to
            compare two objects made with different constructors and prototype.
            `strictEqual()` can be used to test strict equality.
            `notPropEqual()` can be used to explicitly test strict inequality of
            Object properties.
            </summary>
            <param name = "actual">Object or Expression being tested</param>
            <param name = "expected">Known comparison value</param>
            <param name = "message">A short description of the assertion</param>
        </member>
        <member name="M:Retyped.qunit.Assert.pushResult(Retyped.qunit.Assert.pushResultConfig)">
            <summary>
            Report the result of a custom assertion
            Some test suites may need to express an expectation that is not defined
            by any of QUnit's built-in assertions. This need may be met by
            encapsulating the expectation in a JavaScript function which returns a
            `Boolean` value representing the result; this value can then be passed
            into QUnit's `ok` assertion.
            A more readable solution would involve defining a custom assertion. If
            the expectation function invokes `pushResult`, QUnit will be notified of
            the result and report it accordingly.
            </summary>
        </member>
        <member name="M:Retyped.qunit.Assert.strictEqual(System.Object,System.Object)">
            <summary>
            A strict type and value comparison.
            The `strictEqual()` assertion provides the most rigid comparison of type
            and value with the strict equality operator (`===`).
            `equal()` can be used to test non-strict equality.
            `notStrictEqual()` can be used to explicitly test strict inequality.
            </summary>
            <param name = "actual">Object or Expression being tested</param>
            <param name = "expected">Known comparison value</param>
        </member>
        <member name="M:Retyped.qunit.Assert.strictEqual(System.Object,System.Object,System.String)">
            <summary>
            A strict type and value comparison.
            The `strictEqual()` assertion provides the most rigid comparison of type
            and value with the strict equality operator (`===`).
            `equal()` can be used to test non-strict equality.
            `notStrictEqual()` can be used to explicitly test strict inequality.
            </summary>
            <param name = "actual">Object or Expression being tested</param>
            <param name = "expected">Known comparison value</param>
            <param name = "message">A short description of the assertion</param>
        </member>
        <member name="M:Retyped.qunit.Assert.throws(System.Action)">
            <summary>
            Test if a callback throws an exception, and optionally compare the thrown
            error.
            When testing code that is expected to throw an exception based on a
            specific set of circumstances, use assert.throws() to catch the error
            object for testing and comparison.
            In very few environments, like Closure Compiler, throws is considered a
            reserved word and will cause an error. For that case, an alias is bundled
            called `raises`. It has the same signature and behaviour, just a
            different name.
            </summary>
        </member>
        <member name="M:Retyped.qunit.Assert.throws(System.Action,System.Object)">
            <summary>
            Test if a callback throws an exception, and optionally compare the thrown
            error.
            When testing code that is expected to throw an exception based on a
            specific set of circumstances, use assert.throws() to catch the error
            object for testing and comparison.
            In very few environments, like Closure Compiler, throws is considered a
            reserved word and will cause an error. For that case, an alias is bundled
            called `raises`. It has the same signature and behaviour, just a
            different name.
            </summary>
        </member>
        <member name="M:Retyped.qunit.Assert.throws(System.Action,System.Object,System.Object)">
            <summary>
            Test if a callback throws an exception, and optionally compare the thrown
            error.
            When testing code that is expected to throw an exception based on a
            specific set of circumstances, use assert.throws() to catch the error
            object for testing and comparison.
            In very few environments, like Closure Compiler, throws is considered a
            reserved word and will cause an error. For that case, an alias is bundled
            called `raises`. It has the same signature and behaviour, just a
            different name.
            </summary>
        </member>
        <member name="P:Retyped.qunit.Hooks.after">
            <summary>
            Runs after the last test. If additional tests are defined after the
            module's queue has emptied, it will not run this hook again.
            </summary>
        </member>
        <member name="P:Retyped.qunit.Hooks.afterEach">
            <summary>
            Runs after each test.
            </summary>
        </member>
        <member name="P:Retyped.qunit.Hooks.before">
            <summary>
            Runs before the first test.
            </summary>
        </member>
        <member name="P:Retyped.qunit.Hooks.beforeEach">
            <summary>
            Runs before each test.
            </summary>
        </member>
        <member name="P:Retyped.qunit.NestedHooks.after">
            <summary>
            Runs after the last test. If additional tests are defined after the
            module's queue has emptied, it will not run this hook again.
            </summary>
        </member>
        <member name="P:Retyped.qunit.NestedHooks.afterEach">
            <summary>
            Runs after each test.
            </summary>
        </member>
        <member name="P:Retyped.qunit.NestedHooks.before">
            <summary>
            Runs before the first test.
            </summary>
        </member>
        <member name="P:Retyped.qunit.NestedHooks.beforeEach">
            <summary>
            Runs before each test.
            </summary>
        </member>
        <member name="P:Retyped.qunit.QUnit.Interface.assert">
            <summary>
            Namespace for QUnit assertions
            QUnit's built-in assertions are defined on the `QUnit.assert` object. An
            instance of this object is passed as the only argument to the `QUnit.test`
            function callback.
            This object has properties for each of QUnit's built-in assertion methods.
            </summary>
        </member>
        <member name="M:Retyped.qunit.QUnit.Interface.begin(Retyped.qunit.QUnit.beginFn)">
            <summary>
            Register a callback to fire whenever the test suite begins.
            `QUnit.begin()` is called once before running any tests.
            @callback callback Callback to execute.
            </summary>
        </member>
        <member name="P:Retyped.qunit.QUnit.Interface.config">
            <summary>
            Configuration for QUnit
            QUnit has a bunch of internal configuration defaults, some of which are
            useful to override. Check the description for each option for details.
            </summary>
        </member>
        <member name="M:Retyped.qunit.QUnit.Interface.done(Retyped.qunit.QUnit.doneFn)">
            <summary>
            Register a callback to fire whenever the test suite ends.
            </summary>
            <param name = "callback">Callback to execute</param>
        </member>
        <member name="P:Retyped.qunit.QUnit.Interface.dump">
            <summary>
            Advanced and extensible data dumping for JavaScript.
            This method does string serialization by parsing data structures and
            objects. It parses DOM elements to a string representation of their outer
            HTML. By default, nested structures will be displayed up to five levels
            deep. Anything beyond that is replaced by `[object Object]` and
            `[object Array]` placeholders.
            If you need more or less output, change the value of `QUnit.dump.maxDepth`,
            representing how deep the elements should be parsed.
            Note: This method used to be in QUnit.jsDump, which was changed to
            QUnit.dump. The old property will be removed in QUnit 3.0.
            </summary>
        </member>
        <member name="M:Retyped.qunit.QUnit.Interface.extend(System.Object,System.Object)">
            <summary>
            Copy the properties defined by the `mixin` object into the `target` object.
            This method will modify the `target` object to contain the "own" properties
            defined by the `mixin`. If the `mixin` object specifies the value of any
            attribute as undefined, this property will instead be removed from the
            `target` object.
            </summary>
            <param name = "target">An object whose properties are to be modified</param>
            <param name = "mixin">An object describing which properties should be modified</param>
        </member>
        <member name="M:Retyped.qunit.QUnit.Interface.log(Retyped.qunit.QUnit.logFn)">
            <summary>
            Register a callback to fire whenever an assertion completes.
            This is one of several callbacks QUnit provides. Its intended for
            integration scenarios like PhantomJS or Jenkins. The properties of the
            details argument are listed below as options.
            </summary>
            <param name = "callback">Callback to execute</param>
        </member>
        <member name="M:Retyped.qunit.QUnit.Interface.module(System.String)">
            <summary>
            Group related tests under a single label.
            You can use the module name to organize, select, and filter tests to run.
            All tests inside a module callback function will be grouped into that
            module. The test names will all be preceded by the module name in the
            test results. Other modules can be nested inside this callback function,
            where their tests' names will be labeled by their names recursively
            prefixed by their parent modules.
            If `QUnit.module` is defined without a `nested` callback argument, all
            subsequently defined tests will be grouped into the module until another
            module is defined.
            Modules with test group functions allow you to define nested modules, and
            QUnit will run tests on the parent module before going deep on the nested
            ones, even if they're declared first. Additionally, any hook callbacks on
            a parent module will wrap the hooks on a nested module. In other words,
            `before` and `beforeEach` callbacks will form a queue while the
            `afterEach` and `after` callbacks will form a stack.
            You can specify code to run before and after tests using the hooks
            argument, and also to create properties that will be shared on the
            testing context. Any additional properties on the `hooks` object will be
            added to that context. The `hooks` argument is still optional if you call
            `QUnit.module` with a callback argument.
            The module's callback is invoked with the test environment as its `this`
            context, with the environment's properties copied to the module's tests,
            hooks, and nested modules. Note that changes on tests' `this` are not
            preserved between sibling tests, where `this` will be reset to the initial
            value for each test.
            </summary>
            <param name = "name">Label for this group of tests</param>
        </member>
        <member name="M:Retyped.qunit.QUnit.Interface.module(System.String,Retyped.qunit.Hooks)">
            <summary>
            Group related tests under a single label.
            You can use the module name to organize, select, and filter tests to run.
            All tests inside a module callback function will be grouped into that
            module. The test names will all be preceded by the module name in the
            test results. Other modules can be nested inside this callback function,
            where their tests' names will be labeled by their names recursively
            prefixed by their parent modules.
            If `QUnit.module` is defined without a `nested` callback argument, all
            subsequently defined tests will be grouped into the module until another
            module is defined.
            Modules with test group functions allow you to define nested modules, and
            QUnit will run tests on the parent module before going deep on the nested
            ones, even if they're declared first. Additionally, any hook callbacks on
            a parent module will wrap the hooks on a nested module. In other words,
            `before` and `beforeEach` callbacks will form a queue while the
            `afterEach` and `after` callbacks will form a stack.
            You can specify code to run before and after tests using the hooks
            argument, and also to create properties that will be shared on the
            testing context. Any additional properties on the `hooks` object will be
            added to that context. The `hooks` argument is still optional if you call
            `QUnit.module` with a callback argument.
            The module's callback is invoked with the test environment as its `this`
            context, with the environment's properties copied to the module's tests,
            hooks, and nested modules. Note that changes on tests' `this` are not
            preserved between sibling tests, where `this` will be reset to the initial
            value for each test.
            </summary>
            <param name = "name">Label for this group of tests</param>
        </member>
        <member name="M:Retyped.qunit.QUnit.Interface.module(System.String,Retyped.qunit.Hooks,Retyped.qunit.QUnit.moduleFn)">
            <summary>
            Group related tests under a single label.
            You can use the module name to organize, select, and filter tests to run.
            All tests inside a module callback function will be grouped into that
            module. The test names will all be preceded by the module name in the
            test results. Other modules can be nested inside this callback function,
            where their tests' names will be labeled by their names recursively
            prefixed by their parent modules.
            If `QUnit.module` is defined without a `nested` callback argument, all
            subsequently defined tests will be grouped into the module until another
            module is defined.
            Modules with test group functions allow you to define nested modules, and
            QUnit will run tests on the parent module before going deep on the nested
            ones, even if they're declared first. Additionally, any hook callbacks on
            a parent module will wrap the hooks on a nested module. In other words,
            `before` and `beforeEach` callbacks will form a queue while the
            `afterEach` and `after` callbacks will form a stack.
            You can specify code to run before and after tests using the hooks
            argument, and also to create properties that will be shared on the
            testing context. Any additional properties on the `hooks` object will be
            added to that context. The `hooks` argument is still optional if you call
            `QUnit.module` with a callback argument.
            The module's callback is invoked with the test environment as its `this`
            context, with the environment's properties copied to the module's tests,
            hooks, and nested modules. Note that changes on tests' `this` are not
            preserved between sibling tests, where `this` will be reset to the initial
            value for each test.
            </summary>
            <param name = "name">Label for this group of tests</param>
            <param name = "nested">A callback with grouped tests and nested modules to run under the current module label</param>
        </member>
        <member name="M:Retyped.qunit.QUnit.Interface.module(System.String,Retyped.qunit.QUnit.moduleFn)">
            <summary>
            Group related tests under a single label.
            You can use the module name to organize, select, and filter tests to run.
            All tests inside a module callback function will be grouped into that
            module. The test names will all be preceded by the module name in the
            test results. Other modules can be nested inside this callback function,
            where their tests' names will be labeled by their names recursively
            prefixed by their parent modules.
            If `QUnit.module` is defined without a `nested` callback argument, all
            subsequently defined tests will be grouped into the module until another
            module is defined.
            Modules with test group functions allow you to define nested modules, and
            QUnit will run tests on the parent module before going deep on the nested
            ones, even if they're declared first. Additionally, any hook callbacks on
            a parent module will wrap the hooks on a nested module. In other words,
            `before` and `beforeEach` callbacks will form a queue while the
            `afterEach` and `after` callbacks will form a stack.
            You can specify code to run before and after tests using the hooks
            argument, and also to create properties that will be shared on the
            testing context. Any additional properties on the `hooks` object will be
            added to that context. The `hooks` argument is still optional if you call
            `QUnit.module` with a callback argument.
            The module's callback is invoked with the test environment as its `this`
            context, with the environment's properties copied to the module's tests,
            hooks, and nested modules. Note that changes on tests' `this` are not
            preserved between sibling tests, where `this` will be reset to the initial
            value for each test.
            </summary>
            <param name = "name">Label for this group of tests</param>
            <param name = "nested">A callback with grouped tests and nested modules to run under the current module label</param>
        </member>
        <member name="M:Retyped.qunit.QUnit.Interface.moduleDone(Retyped.qunit.QUnit.moduleDoneFn)">
            <summary>
            Register a callback to fire whenever a module ends.
            </summary>
            <param name = "callback">Callback to execute</param>
        </member>
        <member name="M:Retyped.qunit.QUnit.Interface.moduleStart(Retyped.qunit.QUnit.moduleStartFn)">
            <summary>
            Register a callback to fire whenever a module begins.
            </summary>
            <param name = "callback">Callback to execute</param>
        </member>
        <member name="M:Retyped.qunit.QUnit.Interface.only(System.String,Retyped.qunit.QUnit.onlyFn)">
            <summary>
            Adds a test to exclusively run, preventing all other tests from running.
            Use this method to focus your test suite on a specific test. QUnit.only
            will cause any other tests in your suite to be ignored.
            Note, that if more than one QUnit.only is present only the first instance
            will run.
            This is an alternative to filtering tests to run in the HTML reporter. It
            is especially useful when you use a console reporter or in a codebase
            with a large set of long running tests.
            </summary>
            <param name = "name">Title of unit being tested</param>
            <param name = "callback">Function to close over assertions</param>
        </member>
        <member name="M:Retyped.qunit.QUnit.Interface.push(System.Boolean,System.Object,System.Object,System.String)">
            <summary>
            DEPRECATED: Report the result of a custom assertion.
            This method is deprecated and it's recommended to use pushResult on its
            direct reference in the assertion context.
            QUnit.push reflects to the current running test, and it may leak
            assertions in asynchronous mode. Checkout assert.pushResult() to set a
            proper custom assertion.
            Invoking QUnit.push allows to create a readable expectation that is not
            defined by any of QUnit's built-in assertions.
            @deprecated
            </summary>
        </member>
        <member name="M:Retyped.qunit.QUnit.Interface.skip(System.String)">
            <summary>
            Adds a test like object to be skipped.
            Use this method to replace QUnit.test() instead of commenting out entire
            tests.
            This test's prototype will be listed on the suite as a skipped test,
            ignoring the callback argument and the respective global and module's
            hooks.
            </summary>
        </member>
        <member name="M:Retyped.qunit.QUnit.Interface.skip(System.String,Retyped.qunit.QUnit.skipFn)">
            <summary>
            Adds a test like object to be skipped.
            Use this method to replace QUnit.test() instead of commenting out entire
            tests.
            This test's prototype will be listed on the suite as a skipped test,
            ignoring the callback argument and the respective global and module's
            hooks.
            </summary>
        </member>
        <member name="M:Retyped.qunit.QUnit.Interface.stack">
            <summary>
            Returns a single line string representing the stacktrace (call stack).
            This method returns a single line string representing the stacktrace from
            where it was called. According to its offset argument, `QUnit.stack()` will
            return the correspondent line from the call stack.
            The default `offset` is `0` and will return the current location where it
            was called.
            Not all browsers support retrieving stracktraces. In those, `QUnit.stack()`
            will return undefined.
            </summary>
        </member>
        <member name="M:Retyped.qunit.QUnit.Interface.stack(System.Double)">
            <summary>
            Returns a single line string representing the stacktrace (call stack).
            This method returns a single line string representing the stacktrace from
            where it was called. According to its offset argument, `QUnit.stack()` will
            return the correspondent line from the call stack.
            The default `offset` is `0` and will return the current location where it
            was called.
            Not all browsers support retrieving stracktraces. In those, `QUnit.stack()`
            will return undefined.
            </summary>
            <param name = "offset">Set the stacktrace line offset.</param>
        </member>
        <member name="M:Retyped.qunit.QUnit.Interface.start">
            <summary>
            `QUnit.start()` must be used to start a test run that has
            `QUnit.config.autostart` set to `false`.
            This method was previously used to control async tests on text contexts
            along with QUnit.stop. For asynchronous tests, use assert.async instead.
            When your async test has multiple exit points, call `QUnit.start()` for the
            corresponding number of `QUnit.stop()` increments.
            </summary>
        </member>
        <member name="M:Retyped.qunit.QUnit.Interface.test(System.String,Retyped.qunit.QUnit.testFn)">
            <summary>
            Add a test to run.
            Add a test to run using `QUnit.test()`.
            The `assert` argument to the callback contains all of QUnit's assertion
            methods. Use this argument to call your test assertions.
            `QUnit.test()` can automatically handle the asynchronous resolution of a
            Promise on your behalf if you return a thenable Promise as the result of
            your callback function.
            </summary>
            <param name = "callback">Function to close over assertions</param>
        </member>
        <member name="M:Retyped.qunit.QUnit.Interface.testDone(Retyped.qunit.QUnit.testDoneFn)">
            <summary>
            Register a callback to fire whenever a test ends.
            </summary>
            <param name = "callback">Callback to execute</param>
        </member>
        <member name="M:Retyped.qunit.QUnit.Interface.testStart(Retyped.qunit.QUnit.testStartFn)">
            <summary>
            Register a callback to fire whenever a test begins.
            </summary>
            <param name = "callback">Callback to execute</param>
        </member>
        <member name="M:Retyped.qunit.QUnit.Interface.todo(System.String)">
            <summary>
            Adds a test which expects at least one failing assertion during its run.
            Use this method to test a unit of code which is still under development
            (in a “todo” state). The test will pass as long as one failing assertion
            is present.
            If all assertions pass, then the test will fail signaling that QUnit.todo
            should be replaced by QUnit.test.
            </summary>
        </member>
        <member name="M:Retyped.qunit.QUnit.Interface.todo(System.String,Retyped.qunit.QUnit.todoFn)">
            <summary>
            Adds a test which expects at least one failing assertion during its run.
            Use this method to test a unit of code which is still under development
            (in a “todo” state). The test will pass as long as one failing assertion
            is present.
            If all assertions pass, then the test will fail signaling that QUnit.todo
            should be replaced by QUnit.test.
            </summary>
            <param name = "callback">Function to close over assertions</param>
        </member>
        <member name="P:Retyped.qunit.QUnit.Interface.isLocal">
            <summary>
            Are the test running from the server or not.
            </summary>
        </member>
        <member name="P:Retyped.qunit.QUnit.Interface.version">
            <summary>
            QUnit version
            </summary>
        </member>
    </members>
</doc>
